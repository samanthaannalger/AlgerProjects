HardyWeinberg3 <- function(p=runif(1)) {
if(p > 1.0 | p < 0.0) {
stop("Function failure: p must be >=0 and <=1")
}
q <- 1 - p
fAA <- p^2
fAB <- 2*p*q
fBB <- q^2
vecOut <- signif(c(p=p,AA=fAA,AB=fAB,BB=fBB),digits=3)
return(vecOut)
}
HardyWeinberg3(1.2)
z <- HardyWeinberg3(1.2)
myFunc <- function(a=3,b=4) {
z <- a + b
return(z)
}
myFunc()
print(z)
print(a)
myFuncBad <- function(a=3) {
z <- a + b
return(z)
}
myfuncBad()
b <- 10
myfuncBad()
b <- 10
myfuncBad()
myFuncBad <- function(a=3) {
z <- a + b
return(z)
}
b <- 10
myFuncBad()
myFuncBad() # function fails because b is not assigned
myFuncOK <- function(a=3) {
bb <- 100
z <- a + bb
return(z)
}
myFuncOK()
fitLinear <- function(x=runif(10),y=runif(10)){
myMod <- lm(y~x)
myOut <- c(slope=summary(myMod)$coefficients[2,1],
pvalue=summary(myMod)$coefficients[2,4])
plot(x=x,y=y)
return(myOut)
}
fitLinear()
library(ggmap)
install.packages("ggmap")
install.packages("ggplot2")
library(ggmap)
library(ggplot2)
Vtmap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
vtmap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
library(ggmap)
library(ggplot2)
vtmap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
library(ggmap)
library(ggplot2)
vtMap<-get_map(location=c(-72.6954,44.127),zoom=5, source="google",maptype="terrain")
ggmap(vtMap)
get_map(location = c(lon = -72.695461, lat = 44.127084), zoom = "auto", scale = "auto", maptype = c("terrain", "terrain-background", "satellite", "roadmap", "hybrid", "toner", "watercolor", "terrain-labels", "terrain-lines", "toner-2010", "toner-2011", "toner-background", "toner-hybrid", "toner-labels", "toner-lines", "toner-lite"), source = c("google", "osm", "stamen", "cloudmade"), force = ifelse(source == "google", TRUE, TRUE), messaging = FALSE, urlonly = FALSE, filename = "ggmapTemp", crop = TRUE, color = c("color", "bw"), language = "en-EN", api_key)
vtMap <- get_map(location = c(lon = -72.695461, lat = 44.127084), zoom = "auto", scale = "auto", source = "google", TRUE, TRUE)
vtMap <- get_map(location = c(lon = -72.695461, lat = 44.127084), zoom = "auto", scale = "auto", source = "google")
ggmap(vtMap)
vtMap
ggmap(vtMap)
map(vtMap)
install.packages("maps")
library(ggmap)
library(ggplot2)
vtMap<-get_map(location=c(-72.6954,44.127),zoom="auto", scale="auto", source="google",maptype="terrain")
vtMap
vtMap<-get_map(location=c(-72.6954,44.127),zoom="auto", scale="auto", source="google",maptype="terrain")
ggmap(vtMap)
install.packages("ggproto")
install.packages("ggmap", type = "source")
install.packages("ggmap", type = "source")
.75*350
x <- c("ggmap", "rdgal", "rgeos", "maptools", "dplyr", "tidyr", "tmap")
install.packages(x)
lapply(x, library, character.only = TRUE)
install.packages('rgdal',repos="http://www.stats.ox.ac.uk/pub/RWin")
install.packages('rgdal',configure.args="--with-proj-include=/sw/proj/4.9.2/include --with-proj-lib=/sw/proj/4.9.2/lib")
libray(rdgal)
library(rdgal)
require(rdgal)
library(tmap) # load tmap package
tmap_mode="plot"
# load spatial data included in the tmap package
data("World", "metro")
# Try typing head(World$...) or head(metro@...) to see the type of data...
head(World@data)
quick plot example:
qtm(World, fill = "income_grp", text = "iso_a3", text.size = "AREA") # use "World$" to see the two attributes: income_grp and iso_a3, text.size= area: text is sized increasingly with coutry area size.
citation("vegan")
library("ggplot2")
library("dplyr")
library("plyr")
library("spdep")
library("lme4")
#Preliminaries:
# Clear memory of characters
ls()
rm(list=ls())
# Call Packages
library("RColorBrewer")
log(3640689.838+1)
log10(3640689.838+1)
shiny::runApp('AlgerProjects/VTApiaries/shinyappApiaries/ShinyMapApp')
runApp('AlgerProjects/VTApiaries/shinyappApiaries/ShinyMapApp')
runApp('AlgerProjects/VTApiaries/shinyappApiaries/ShinyMapApp')
# Barplot
bp<- ggplot(mitedf, aes(x="", y=value, fill=group))+
geom_bar(width = 1, stat = "identity")
###########################################################################################
# Vermont Apiary Inspeciton Data
# Samantha Alger
# June 10, 2018
###########################################################################################
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
# Set Working Directory:
setwd("~/AlgerProjects/VTApiaries/")
# source my packages
library(plyr)
library(ggplot2)
library(dplyr)
library(lme4)
library(car)
library(tidyr)
library(slam)
library(tm)
library(SnowballC)
library(wordcloud)
library(RColorBrewer)
###########################################################
# Read in Data
FullApiaryDat <- read.csv("CSV_files/VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
HistDat <- read.csv("CSV_files/histDat.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
ApiaryDat <- read.csv("CSV_files/singles.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
states <- read.csv("CSV_files/USstates.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
RegData <- read.csv("CSV_files/RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
ApiaryRegs2017 <- read.csv("CSV_files/2017ApiaryRegs.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
#Remove duplicate data so that there is only a single row for each beekeeper (to be used in all analyses except apiary-level analyses and vendor information)
Singles <- FullApiaryDat[!duplicated(FullApiaryDat$BeekeeperID), ]
#write.csv(Singles, file = "singles.csv")
##################################################
#########################################################
#########################################################
# Basic Statistics:
#########################################################
#########################################################
# Calculating state level losses:
AnnLoss<- RegData[! is.na(RegData$PerTotLoss), ]
mean(AnnLoss$PerTotLoss)
# 38.8%: Total Annual
WinterLoss<- RegData[! is.na(RegData$PerWinLoss), ]
mean(WinterLoss$PerWinLoss)
# 35.8% Winter Loss
# Summer loss??
#Calculating apiary and colony totals:
# Subset to only include status="Active" beekeepers (remove NAs too)
ActiveOnly<- RegData[! is.na(RegData$BeeKeeperStatus), ]
ActiveOnly<- ActiveOnly[ which(ActiveOnly$BeeKeeperStatus == "Active"), ]
nrow(ActiveOnly)
# 1091 Registered Apiaries
#How many apiaries are delinquent?
DelOnly<- RegData[ which(RegData$BeeKeeperStatus == "Delinquent"), ]
nrow(DelOnly)
# 465 delinquent apiaries
#How many registered Colonies?
ActiveOnly<- ActiveOnly[! is.na(ActiveOnly$ColonyCount), ]
sum(ActiveOnly$ColonyCount)
# 8,450 registered colonies
#Calculate the number of registered beekeepers:
ActiveBeeks <- ActiveOnly[!duplicated(ActiveOnly$BeekeeperID), ]
nrow(ActiveBeeks)
# 743 Active registered beekeepers
DelBeeks <- DelOnly[!duplicated(DelOnly$BeekeeperID), ]
nrow(DelBeeks)
#254 Delinquent beekeepers
#Determine the number of apiaries each beekeeper has registered and create a histogram....
#For registered beekeepers:
library(data.table)
histDat = data.table(ActiveOnly)
histDat[, `n` := .N, by = BeekeeperID]
#histDat <-  histDat[!duplicated(histDat$BeekeeperID),]
# Histogram showing the number of apiaries belonging to beekeepers with 1 yard, two yards...etc...
hist(histDat$n, freq=TRUE, breaks=25)
###############################################
#Code apiaries as owned by either hobbists, sideliners, or commericial apiaries
histDat$Beektype <- ifelse(histDat$n == 1,"Hobbyist", ifelse(histDat$n <=5, "Sideliner", "Commercial"))
# Write.csv hist dat for shiny app demo
#write.csv(histDat,"histDat.csv")
BeekTypeStats <- ddply(histDat, c("Beektype"), summarise,
apiaries = length(n),
colonies = sum(ColonyCount),
loss = mean(PerTotLoss, na.rm = TRUE),
sd = sd(PerTotLoss, na.rm=TRUE),
se = sd / sqrt(apiaries))
BeekTypeStats$perApiaries <- BeekTypeStats$apiaries/sum(BeekTypeStats$apiaries)
BeekTypeStats$perColonies <- BeekTypeStats$colonies/sum(BeekTypeStats$colonies)
BeekTypeStats
BeekTypeDF <- rbind(BeekTypeStats, BeekTypeStats)
MeasureType <- c(rep("Apiary", 3), rep("Colony", 3))
BeekTypeDF <- cbind(BeekTypeDF, MeasureType)
BeekTypeDF$Percent <- c(BeekTypeDF$perApiaries[1:3], BeekTypeDF$perColonies[4:6])
BeekTypeDF
#Are there significant differences in hive losses among beekeeper types?
#Currenlty no significant differences! p = 0.09
BeekTypeLoss <- aov(histDat$PerTotLoss~histDat$Beektype)
summary(BeekTypeLoss)
# Check to see which beekeepers told us about hive losses... #MISSING LOTS OF COLONY LOSS DATA FROM COMMERICIAL BEEKEEPERS!!
NAcheck<-histDat[is.na(histDat$PerTotLoss),]
table(NAcheck$Beektype)
#Create figure showing number of colonies and number of apiaries as BeekType.
#Create labels.....
#Reorder factors:
BeekTypeDF$Beektype <- factor(BeekTypeDF$Beektype, levels = c("Sideliner", "Hobbyist", "Commercial"))
BeekTypeDF <- ddply(BeekTypeDF, .(MeasureType), transform, pos = cumsum(Percent) - (0.5 * Percent))
BeekTypeFig <- ggplot(BeekTypeDF, aes(y = Percent, x = MeasureType , fill = Beektype)) + geom_bar(stat="identity") + theme_classic() + labs(x=NULL, y = "Percent of total in Vermont")+ scale_y_continuous(labels = scales::percent) +
scale_fill_brewer() +
scale_x_discrete(labels=c("Apiary" = "Apiaries", "Colony" = "Colonies")) + guides(fill=guide_legend(title="Beekeeper Type")) + geom_text(data=BeekTypeDF, aes(x = MeasureType, y = pos ,label = paste0(round(Percent*100, digits = 1),"%")), size=4)
BeekTypeFig
#########################################################
#########################################################
# Creating a word cloud from the 'opinion' column:
#########################################################
#########################################################
#Combine all Text:
OpinionText <- paste(unlist(ApiaryDat$Opinion), collapse =" ")
# I then copied and pasted the above text to a .txt file and saved it in .csv folder. Is there a way to do this in R?
#text <- readLines("CSV_files/WordCloud2.txt")
docs <- Corpus(VectorSource(OpinionText))
text <- readLines("CSV_files/WordCloud.txt")
#docs <- Corpus(VectorSource(text))
#docs <- tm_map(docs, content_transformer(tolower))
inspect(docs)
toSpace <- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
docs <- tm_map(docs, toSpace, "/")
docs <- tm_map(docs, toSpace, "@")
docs <- tm_map(docs, toSpace, "\\|")
# Convert the text to lower case
docs <- tm_map(docs, content_transformer(tolower))
# Remove numbers
docs <- tm_map(docs, removeNumbers)
# Remove english common stopwords
docs <- tm_map(docs, removeWords, stopwords("english"))
# Remove your own stop word
# specify your stopwords as a character vector
docs <- tm_map(docs, removeWords, c("bees", "year", "keeping","will", "use", "enough", "getting", "one", "many", "just", "last", "keep", "good", "one", "also", "sure", "bee", "lost","hives","hive","left", "hard", "proper", "long", "someone", "need", "every", "make", "low", "late", "right", "finding", "two", "area", "best", "put", "well", "using", "trying", "due", "lot", "start", "find", "may", "going", "even", "get", "past", "biggest","check", "another", "much", "purchased","now", "can"))
# Remove punctuations
docs <- tm_map(docs, removePunctuation)
# Eliminate extra white spaces
docs <- tm_map(docs, stripWhitespace)
# Text stemming
# docs <- tm_map(docs, stemDocument)
dtm <- TermDocumentMatrix(docs)
m <- as.matrix(dtm)
v <- sort(rowSums(m),decreasing=TRUE)
d <- data.frame(word = names(v),freq=v)
head(d, 10)
#Generating word cloud
set.seed(1234)
wordcloud(words = d$word, freq = d$freq, min.freq = 10,
max.words=200, random.order=FALSE, rot.per=0.35,
colors=brewer.pal(8, "Dark2"))
#########################################################
#########################################################
# Mite Monitoring
#########################################################
#########################################################
##########################################################
# Percentage of beekeepers that count mites:
#Create a Pie chart for mite counts, (yes/no)
mitedf <- data.frame(
group = c("Did not count mites", "Counted mites"),
value = c(table(ApiaryDat$MiteCounts))
)
head(mitedf)
#     group value
# 1 Counted   221....34.8%
# 2 Did not   414...65.2%
library(ggplot2)
library(scales)
# Barplot
bp<- ggplot(mitedf, aes(x="", y=value, fill=group))+
geom_bar(width = 1, stat = "identity")
bp
Singles <- Shinydf[!duplicated(Shinydf$BeekeeperID), ]
# Shiny App for Beeks!
# July 26, 2018
# Samantha Alger
# Clear memory of characters:
rm(list=ls())
library(rgdal)
library(rgeos)
library(plyr)
library(data.table)
library(leaflet)
library(rgdal)
library(shiny)
library(shinythemes)
library(markdown)
library(knitr)
library(DT)
library(expss)
library(ggplot2)
#library(lemon)
#library(kableExtra)
#set working director
setwd("~/AlgerProjects/VTApiaries/shinyappApiaries")
#upload data
RegData <- read.csv("RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
##############################################################
# DATA PREP:
##############################################################
# Data cleaning to make final df:
histDat = data.table(RegData)
histDat[, `n` := .N, by = BeekeeperID]
#histDat <-  histDat[!duplicated(histDat$BeekeeperID),]
histDat$Beektype <- ifelse(histDat$n == 1,"Hobbyist", ifelse(histDat$n <=5, "Sideliner", "Commercial"))
################################################
#Merging the two dataframes for shiny app:
#select only columns we need:
histDat <- dplyr::select(histDat, LocationID, Beektype, AccountName, BeeKeeperStatus, n)
FullApiaryDat <- dplyr::select(FullApiaryDat, -AccountName, -BeeKeeperStatus)
Shinydf <- merge.data.frame(FullApiaryDat,histDat, by = "LocationID", all.y = TRUE)
Singles <- Shinydf[!duplicated(Shinydf$BeekeeperID), ]
mitedf <- data.frame(
group = c("Did not count mites", "Counted mites"),
value = c(table(Singles$MiteCounts))
)
# Barplot
bp<- ggplot(mitedf, aes(x="", y=value, fill=group))+
geom_bar(width = 1, stat = "identity")
#Create a blank theme
blank_theme <- theme_minimal()+
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.border = element_blank(),
panel.grid=element_blank(),
axis.ticks = element_blank(),
plot.title=element_text(size=14, face="bold")
)
#Piechart
pie <- bp + coord_polar("y", start=0) +
theme_minimal() +  blank_theme +
theme(axis.text.x=element_blank()) + guides(fill=guide_legend(title="Percentage of beekeepers"))
pie
library(plotly)
ggplotly(pie)
p <- plot_ly(mitedf, labels = ~group, values = ~y, type = 'pie') %>%
layout(title = 'United States Personal Expenditures by Categories in 1960',
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
p
p <- plot_ly(mitedf, labels = ~group, values = ~value, type = 'pie') %>%
layout(title = 'United States Personal Expenditures by Categories in 1960',
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
p
p <- plot_ly(mitedf, labels = ~group, values = ~value, type = 'pie') %>%
layout( xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
p
runApp('ShinyBeeks')
runApp('ShinyBeeks')
# Clear memory of characters:
rm(list=ls())
library(rgdal)
library(rgeos)
library(plyr)
library(data.table)
library(leaflet)
library(rgdal)
library(shiny)
library(shinythemes)
library(markdown)
library(knitr)
library(DT)
library(expss)
library(ggplot2)
#set working director
setwd("~/AlgerProjects/VTApiaries/shinyappApiaries")
#upload data
RegData <- read.csv("RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
# Data cleaning to make final df:
histDat = data.table(RegData)
histDat[, `n` := .N, by = BeekeeperID]
histDat$Beektype <- ifelse(histDat$n == 1,"Hobbyist", ifelse(histDat$n <=5, "Sideliner", "Commercial"))
#select only columns we need:
histDat <- dplyr::select(histDat, LocationID, Beektype, AccountName, BeeKeeperStatus, n)
FullApiaryDat <- dplyr::select(FullApiaryDat, -AccountName, -BeeKeeperStatus)
Shinydf <- merge.data.frame(FullApiaryDat,histDat, by = "LocationID", all.y = TRUE)
CountySummary <- ddply(Shinydf,c("CountyName"), summarise,
Loss = round(100* mean(PerTotLoss, na.rm=TRUE), digits = 2),
apiaries = length(n),
colonies = sum(ColonyCount),
beeks = length(unique(unlist(BeekeeperID[!is.na(BeekeeperID)]))),
n = length(n),
nLoss = length(PerTotLoss [!is.na(PerTotLoss)]),
MiteTrue = length(MiteCounts[MiteCounts==TRUE]),
MiteFalse = length(MiteCounts[MiteCounts==FALSE]),
PerMiteTrue = round(100*(MiteTrue/length(MiteCounts [!is.na(MiteCounts)])),digits = 2))
#rename countyname column
names(CountySummary)[1] <- "NAME"
# read in geojson data (county basemaps)
vtcounties <- rgdal::readOGR(dsn="cb_2017_us_county_5m.geojson")
#subset to only include vermont
vermont <- vtcounties[vtcounties@data$STATEFP == 50, ]
#merge the summary data with the base map data
vermont <- merge(vermont, CountySummary)
#rename the 'data' slot of the vermont spatial dataframe. Use the '@' symbol to refer to the slot name 'data', and drop unused levels to reduce the df to the VT counties only:
vermontdf <- droplevels(vermont@data)
#select only columns we will need for the summary tables
vermontdf<- dplyr::select(vermontdf, NAME, Loss, apiaries, colonies, nLoss, n, PerMiteTrue, beeks)
BeekTypeStats <- ddply(Shinydf, c("Beektype"), summarise,
apiaries = length(n),
colonies = sum(ColonyCount, na.rm = TRUE),
loss = round(100*mean(PerTotLoss, na.rm = TRUE),digits=2),
sd = sd(100*PerTotLoss, na.rm=TRUE),
se = sd / sqrt(apiaries))
BeekTypeStats$perApiaries <- round(100*BeekTypeStats$apiaries/sum(BeekTypeStats$apiaries), digits=2)
BeekTypeStats$perColonies <- round(100*BeekTypeStats$colonies/sum(BeekTypeStats$colonies), digits=2)
# Code for stacked bar plot
BeekTypeDF <- rbind(BeekTypeStats, BeekTypeStats)
MeasureType <- c(rep("Apiary", 3), rep("Colony", 3))
BeekTypeDF <- cbind(BeekTypeDF, MeasureType)
BeekTypeDF$Percent <- c(BeekTypeDF$perApiaries[1:3], BeekTypeDF$perColonies[4:6])
#Reorder factors for stacked bar plot:
BeekTypeDF$Beektype <- factor(BeekTypeDF$Beektype, levels = c("Hobbyist","Sideliner", "Commercial"))
# Reorder factors for colony loss bar plot:
BeekTypeStats$Beektype <- factor(BeekTypeStats$Beektype, levels = c("Hobbyist","Sideliner", "Commercial"))
# Create df for Pie Chart:
Singles <- Shinydf[!duplicated(Shinydf$BeekeeperID), ]
mitedf <- data.frame(group = c("Did not count mites", "Counted mites"), value = c(table(Singles$MiteCounts)))
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
runApp('ShinyBeeks')
p <- ggplot(mitedf, labels = ~group, values = ~value, type = 'pie') %>%
layout( xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
runApp('ShinyBeeks')
pie<-Plot_ly(mitedf, labels = ~group,
values = ~value,
type = 'pie') %>%
layout( xaxis = list(showgrid = FALSE,
zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE,
showticklabels = FALSE))
p <- plot_ly(mitedf, labels = ~group, values = ~value, type = 'pie') %>%
layout( xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
p
pie<-plot_ly(mitedf, labels = ~group,
values = ~value,
type = 'pie') %>%
layout( xaxis = list(showgrid = FALSE,
zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE,
showticklabels = FALSE))
pie
runApp('ShinyBeeks')
runApp('ShinyBeeks')
