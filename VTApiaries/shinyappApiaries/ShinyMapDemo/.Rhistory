# How Does med use correlate with colony losses....
#Remove rows with NA in percent loss:
MedData <- FullApiaryDat[! is.na(FullApiaryDat$PerTotLoss), ]
# reorder factors for plotting
MedData$TreatmentsForColonyHealthMitigation <- factor(MedData$TreatmentsForColonyHealthMitigation, levels = c("None", "Powdered sugar", "Honey B Healthy", "Apiguard", "Api-life VAR", "Formic acid (Mite Away Quick Strips)", "Oxalic acid", "Formic acid (Mite Away Quick Strips) Honey B Healthy", "Apiguard, Formic acid (Mite Away Quick Strips)", "Formic acid (Mite Away Quick Strips), Oxalic acid", "Amitraz, Formic acid (Mite Away Quick Strips)"))
Medications <- ddply(MedData, c("TreatmentsForColonyHealthMitigation"), summarise,
n = length(PerTotLoss),
mean = mean(PerTotLoss, na.rm=TRUE),
sd = sd(PerTotLoss, na.rm=TRUE),
se = sd / sqrt(n))
#View the table to see average colony losses by all treatment combinations
#View(Medications)
# Reduce Medication combinations to only include those that appear more than 10 times:
Medications <- Medications[ which(Medications$n > 9), ]
Medications <- Medications[! is.na(Medications$TreatmentsForColonyHealthMitigation), ]
#Create a bar graph
plot1 <- ggplot(Medications, aes(x=TreatmentsForColonyHealthMitigation, y=mean, fill=TreatmentsForColonyHealthMitigation)) +
geom_bar(stat="identity", color="black",
position=position_dodge()) + labs(x="Medications", y = "Colony Loss") + theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5), legend.position="none") + scale_x_discrete(labels=c("Formic acid (Mite Away Quick Strips)" = "MAQS", "Amitraz, Formic acid (Mite Away Quick Strips)" = "Amitraz, MAQS", "Apiguard, Formic acid (Mite Away Quick Strips)" = "Apiguard, MAQS", "Formic acid (Mite Away Quick Strips), Oxalic acid" = "Oxalic acid, MAQS", "Formic acid (Mite Away Quick Strips), Honey B Healthy" = "Honey B Healthy, MAQS")) + scale_y_continuous(labels = scales::percent) + geom_errorbar(aes(ymin = mean - se, ymax = mean + se, width = 0.2)) + scale_fill_brewer()
plot1
#Prepare raw data set for ANOVA:
# Subset data in R
MedANOVA <- subset(FullApiaryDat, TreatmentsForColonyHealthMitigation == "None"| TreatmentsForColonyHealthMitigation =="Powdered sugar" | TreatmentsForColonyHealthMitigation == "Honey B Healthy"| TreatmentsForColonyHealthMitigation == "Apiguard" | TreatmentsForColonyHealthMitigation == "Api-life VAR" |  TreatmentsForColonyHealthMitigation == "Formic acid (Mite Away Quick Strips)" | TreatmentsForColonyHealthMitigation == "Oxalic acid" | TreatmentsForColonyHealthMitigation == "Formic acid (Mite Away Quick Strips) Honey B Healthy" | TreatmentsForColonyHealthMitigation == "Apiguard Formic acid (Mite Away Quick Strips)" | TreatmentsForColonyHealthMitigation == "Formic acid (Mite Away Quick Strips), Oxalic acid" | TreatmentsForColonyHealthMitigation == "Amitraz, Formic acid (Mite Away Quick Strips)")
#remove 'NA's from percent total loss column
MedANOVA <- MedANOVA[! is.na(MedANOVA$PerTotLoss), ]
#Perform ANOVA and post hoc test:
Meds <- aov(MedANOVA$PerTotLoss~MedANOVA$TreatmentsForColonyHealthMitigation)
summary(Meds)
TukeyHSD(Meds)
########################################################
# Reasons for Colony Losses:
#Import data:
CensusDat<- Singles
#Create two separate dfs for analysis with specified columns:
ReasonLoss <- dplyr::select(CensusDat, BeekeeperID, ColonyLossVarroaMiteYN, ColonyLossStarvationYN, ColonyLossBearsYN, ColonyLossAmericanFoulbroodYN, ColonyLossSwarmingYN, ColonyLossPesticidesYN, ColonyLossMitacidesYN, OtherColonyLossYN)
NumLoss <- dplyr::select(CensusDat, BeekeeperID, ColonyLossVarroaMite, ColonyLossStarvation, ColonyLossBears, ColonyLossAmericanFoulbrood, ColonyLossSwarming, ColonyLossPesticides, ColonyLossMitacides, OtherColonyLoss)
OtherLoss <- dplyr::select(CensusDat,OtherColonyLossCausesSpecify)
# Change dataframes from wide to long format
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ReasonLoss <- gather(ReasonLoss, question, response, ColonyLossVarroaMiteYN:OtherColonyLossYN, factor_key=TRUE)
NumLoss <- gather(NumLoss, question, response, ColonyLossVarroaMite:OtherColonyLoss, factor_key=TRUE)
#Convert all True and False to '0' and '1' in the 'ReasonLoss' dataframe
ReasonLoss$response<-as.integer(as.logical(ReasonLoss$response))
# Preparing Data for Bar Plot
LossCause <- ddply(ReasonLoss, c("question"), summarise,
n = length(response),
mean = mean(response, na.rm=TRUE),
sd = sd(response, na.rm=TRUE),
se = sd / sqrt(n))
plot1 <- ggplot(LossCause, aes(x=question, y=mean, fill=question)) +
geom_bar(stat="identity", color="black",
position=position_dodge()) +
labs(x="Causes", y = "% Reported Causes") +
theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5), legend.position="none", axis.text=element_text(size=15), axis.title=element_text(size=18,face="bold")) +
scale_y_continuous(labels = scales::percent) +
geom_errorbar(aes(ymin = mean - se, ymax = mean +
se, width = 0.2)) + scale_fill_brewer() +
scale_x_discrete(labels=c("ColonyLossVarroaMiteYN" = "Varroa", "ColonyLossStarvationYN"= "Starvation", "ColonyLossBearsYN" = "Bears", "ColonyLossAmericanFoulbroodYN" = "AFB", "ColonyLossSwarmingYN" = "Swarming", "ColonyLossPesticidesYN" = "Pesticides", "ColonyLossMitacidesYN" = "Mitacides", "OtherColonyLossYN"= "Other"))
plot1
######################################################
# Create Word Cloud for "OtherLoss"
#Combine all Text:
OtherLossText <- paste(unlist(OtherLoss), collapse =" ")
# I then copied and pasted the above text to a .txt file and saved it in .csv folder. Is there a way to do this in R?
#text <- readLines("CSV_files/WordCloud2.txt")
docs <- Corpus(VectorSource(OtherLossText))
#docs <- tm_map(docs, content_transformer(tolower))
inspect(docs)
toSpace <- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
docs <- tm_map(docs, toSpace, "/")
docs <- tm_map(docs, toSpace, "@")
docs <- tm_map(docs, toSpace, "\\|")
# Convert the text to lower case
docs <- tm_map(docs, content_transformer(tolower))
# Remove numbers
docs <- tm_map(docs, removeNumbers)
# Remove english common stopwords
docs <- tm_map(docs, removeWords, stopwords("english"))
# Remove your own stop word
docs <- tm_map(docs, removeWords, c("they", "due", "left","sure","know", "other", "had", "were", "into", "with", "all", "going", "was","very","over","from"))
# Remove punctuations
docs <- tm_map(docs, removePunctuation)
# Eliminate extra white spaces
docs <- tm_map(docs, stripWhitespace)
# Text stemming
# docs <- tm_map(docs, stemDocument)
dtm <- TermDocumentMatrix(docs)
m <- as.matrix(dtm)
v <- sort(rowSums(m),decreasing=TRUE)
d <- data.frame(word = names(v),freq=v)
head(d, 10)
#Generating word cloud
set.seed(1234)
wordcloud(words = d$word, freq = d$freq, min.freq = 5,
max.words=200, random.order=FALSE, rot.per=0.35,
colors=brewer.pal(8, "Dark2"))
##################################################
# Antibiotic Use
Antibx <- Singles
AntibxFull <- FullApiaryDat
table(Antibx$AntibioticTreatments)
#antibiotic use: 53 of 582 beekeepers (~10 %)
table(AntibxFull$AntibioticTreatments)
# of apiaries = 66
SumAntibx <- AntibxFull[which(AntibxFull$AntibioticTreatments == "TRUE"),]
sum(SumAntibx$ColonyCount)
# 356 hives
#######################################################
# How do you make up for colony losses?
#######################################################
ColLoss <- Singles[! is.na(Singles$ColonyLossMakeup), ]
vec <- c("Make Splits or Divides","Purchase Colonies in Hives","Purchase Packages","Purchase Nucleus Colonies")
mat <- matrix(nrow = length(ColLoss$ColonyLossMakeup), ncol = length(vec))
for (i in 1:length(vec)){
mat[,i] <- grepl(vec[i], ColLoss$ColonyLossMakeup, fixed = TRUE)
}
# turn mat into a data frame, give it column names and merge with MedUse
mat <- data.frame(mat)
names(mat) <- vec
ColLoss <- cbind(ColLoss, mat)
Percents <- colMeans(mat, na.rm=TRUE)
Treatments <- vec
ColLoss <- data.frame(Treatments, Percents)
#Reorder for plotting:
ColLoss$Treatments <- factor(ColLoss$Treatments, levels = c("Make Splits or Divides","Purchase Colonies in Hives","Purchase Packages","Purchase Nucleus Colonies"))
plot3 <- ggplot(ColLoss, aes(x=Treatments, y=Percents)) +
geom_bar(stat="identity", color="black",
position=position_dodge()) + labs(x=NULL, y = "% Responses") + theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5), legend.position="none")  + scale_x_discrete(labels=c("Splits/Divides","Purchase Full Hives","Purchase Packages","Purchase Nucs")) + scale_fill_brewer() + scale_y_continuous(labels = scales::percent) + theme(axis.text=element_text(size=20), axis.title=element_text(size=18,face="bold"))
plot3
##############################################################
# SUBSET Spacial data by lat long Euclidean Distance for mapping purposes:
# Data cleaning to make final df:
histDat = data.table(RegData)
histDat[, `n` := .N, by = BeekeeperID]
#histDat <-  histDat[!duplicated(histDat$BeekeeperID),]
histDat$Beektype <- ifelse(histDat$n == 1,"Hobbyist", ifelse(histDat$n <=5, "Sideliner", "Commercial"))
#######
#Merging the two dataframes for shiny app:
#select only columns we need:
histDat <- dplyr::select(histDat, LocationID, Beektype, AccountName, BeeKeeperStatus, n)
FullApiaryDat <- dplyr::select(FullApiaryDat, -AccountName, -BeeKeeperStatus)
Shinydf <- merge.data.frame(FullApiaryDat,histDat, by = "LocationID", all.y = TRUE)
###########################################################
# Begin Functions
###########################################################
####################################################################
# function name: LatLongMat
# description: Creates matrix with lat and long columns
# parameters:
# data = data frame that includes "Latitude" and "Longitude"
# returns: a matrix with two columns (lat and long)
####################################################################
LatLongMat <- function(data=data){
# create matrix of lats and longs from data set
Latitude <- data$Latitude
Longtitude <- data$Longtitude
x <- cbind(Longtitude, Latitude)
x <- x[complete.cases(x), ]
x <- as.matrix(x)
return(x)
}
#####################################################################
# END OF FUNCTION
####################################################################
####################################################################
# function name: SubSetMap
# description: uses lat long matrix from "LatLongMat" to calculate distance in miles from center point (lat long) and find all apiaries within that radius
# parameters:
# data = data frame that includes "Latitude" and "Longitude"
# rad = radius to query (numeric (miles))
# lat = center point latitude
# long = center point longtitude
# matrix = matrix of lats and longs in two columns
# returns: a list with 4 elements: data frame where all rows are apairies within rad, rad, lat and long
####################################################################
SubSetMap <- function(data = data,
rad = 100,
lat = 42,
long = -72,
matrix = x){
library(geosphere)
# use the sp package to determine Euc. Dist between points in matrix "y" and central point "x"
m <- distm(x = c(lat, long), y = matrix, fun = distHaversine)
m <- as.vector(m)
distance <- m/1609.334
# merge data back to original data frame:
matrix <- as.data.frame(matrix)
temp <- as.data.frame(cbind(matrix$Latitude, matrix$Longtitude, distance))
names(temp) <- c("Latitude", "Longtitude", "distance")
t <- as.data.frame(merge(x=data, y=temp, by = c("Latitude", "Longtitude"), all.y=TRUE, sort=FALSE))
# which are within radius
queryDF <- t[t$distance<=rad,]
return(list(queryDF, rad, lat, long))
}
#####################################################################
# END OF FUNCTION
####################################################################
###########################################################
##########Adding Points to a map###########################
###########################################################
Mapfunc <- function(data=data, rad, lat, long) {
library(leaflet)
content <- paste("Account Name:", data$AccountName, "<br/>",
"BeekeeperID:", data$BeekeeperID, "<br/>",
"Status:", data$BeeKeeperStatus, "<br/>",
"# Colonies:", data$ColonyCount, "<br/>",
"Annual Loss:", data$PerTotLoss*100, "%","<br/>",
"Beekeeper Type:", data$Beektype, "<br/>",
"Last Inspection Date:", data$LastInspectionDate)
m <- leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group="background 1") %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=long , lat=lat,
popup="Outbreak") %>% setView(long, lat, zoom = 8) %>% addCircles(data$Longtitude,data$Latitude, popup=content, weight = 3, radius=40,
color="#ffa500", stroke = TRUE, fillOpacity = 0.8)
return(m)
}
LLmat <- LatLongMat(data = Shinydf)
SSdat <- SubSetMap(data = Shinydf, rad = 20, lat = -72.746286, long = 44.278876, matrix = LLmat)
Mapfunc(data=SSdat[[1]], rad= SSdat[[2]], lat = SSdat[[4]], long= SSdat[[3]])
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Apiary Locator"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
)
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("CSV_files/RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
library(shiny)
runApp('shinyappApiaries/ShinyMapDemo')
setwd("~/AlgerProjects/VTApiaries")
runApp('shinyappApiaries/ShinyMapDemo')
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("CSV_files/RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
library(shiny)
# Data cleaning to make final df:
histDat = data.table(RegData)
histDat[, `n` := .N, by = BeekeeperID]
histDat$Beektype <- ifelse(histDat$n == 1,"Hobbyist", ifelse(histDat$n <=5, "Sideliner", "Commercial"))
#select only columns we need:
histDat <- dplyr::select(histDat, LocationID, Beektype, AccountName, BeeKeeperStatus, n)
FullApiaryDat <- dplyr::select(FullApiaryDat, -AccountName, -BeeKeeperStatus)
Shinydf <- merge.data.frame(FullApiaryDat,histDat, by = "LocationID", all.y = TRUE)
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("CSV_files/RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("CSV_files/VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
runApp('shinyappApiaries/ShinyMapDemo')
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("CSV_files/RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("CSV_files/VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
library(shiny)
# Data cleaning to make final df:
histDat = data.table(RegData)
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("CSV_files/RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("CSV_files/VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
library(shiny)
library(leaflet)
# Data cleaning to make final df:
histDat = data.table(RegData)
histDat[, `n` := .N, by = BeekeeperID]
histDat$Beektype <- ifelse(histDat$n == 1,"Hobbyist", ifelse(histDat$n <=5, "Sideliner", "Commercial"))
#select only columns we need:
histDat <- dplyr::select(histDat, LocationID, Beektype, AccountName, BeeKeeperStatus, n)
FullApiaryDat <- dplyr::select(FullApiaryDat, -AccountName, -BeeKeeperStatus)
Shinydf <- merge.data.frame(FullApiaryDat,histDat, by = "LocationID", all.y = TRUE)
LatLongMat <- function(data=data){
# create matrix of lats and longs from data set
Latitude <- data$Latitude
Longtitude <- data$Longtitude
x <- cbind(Longtitude, Latitude)
x <- x[complete.cases(x), ]
x <- as.matrix(x)
return(x)
}
SubSetMap <- function(data = data,
rad = 100,
lat = 42,
long = -72,
matrix = x){
library(geosphere)
# use the sp package to determine Euc. Dist between points in matrix "y" and central point "x"
m <- distm(x = c(lat, long), y = matrix, fun = distHaversine)
m <- as.vector(m)
distance <- m/1609.334
# merge data back to original data frame:
matrix <- as.data.frame(matrix)
temp <- as.data.frame(cbind(matrix$Latitude, matrix$Longtitude, distance))
names(temp) <- c("Latitude", "Longtitude", "distance")
t <- as.data.frame(merge(x=data, y=temp, by = c("Latitude", "Longtitude"), all.y=TRUE, sort=FALSE))
# which are within radius
queryDF <- t[t$distance<=rad,]
return(list(queryDF, rad, lat, long))
}
Mapfunc <- function(data=data, rad, lat, long) {
library(leaflet)
content <- paste("Account Name:", data$AccountName, "<br/>",
"BeekeeperID:", data$BeekeeperID, "<br/>",
"Status:", data$BeeKeeperStatus, "<br/>",
"# Colonies:", data$ColonyCount, "<br/>",
"Annual Loss:", data$PerTotLoss*100, "%","<br/>",
"Beekeeper Type:", data$Beektype, "<br/>",
"Last Inspection Date:", data$LastInspectionDate)
m <- leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group="background 1") %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=long , lat=lat,
popup="Outbreak") %>% setView(long, lat, zoom = 8) %>% addCircles(data$Longtitude,data$Latitude, popup=content, weight = 3, radius=40,
color="#ffa500", stroke = TRUE, fillOpacity = 0.8)
return(m)
}
#####################################################################
# END OF FUNCTION
####################################################################
# Create df for server:
LLmat <- LatLongMat(data = Shinydf)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
SSdat <- SubSetMap(data = Shinydf, rad = 20, lat = -72.746286, long = 44.278876, matrix = LLmat)
Mapfunc(data=SSdat[[1]], rad= SSdat[[2]], lat = SSdat[[4]], long= SSdat[[3]])
})
}
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
ui <- fluidPage(
leafletOutput("mymap"))
server <- function(input, output, session) {
SubSetMap(data = Shinydf, rad = 20, lat = -72.746286, long = 44.278876, matrix = LLmat)
output$mymap<- Mapfunc(data=SSdat[[1]], rad= SSdat[[2]], lat = SSdat[[4]], long= SSdat[[3]])
}
shinyApp(ui, server)
ui <- fluidPage(
leafletOutput("mymap"))
server <- function(input, output) {
SSdat <- SubSetMap(data = Shinydf, rad = 20, lat = -72.746286, long = 44.278876, matrix = LLmat)
output$mymap<- Mapfunc(data=SSdat[[1]], rad= SSdat[[2]], lat = SSdat[[4]], long= SSdat[[3]])
}
shinyApp(ui, server)
# SHINY MAPPING
SSdat <- SubSetMap(data = Shinydf, rad = 20, lat = -72.746286, long = 44.278876, matrix = LLmat)
ui <- fluidPage(
leafletOutput("mymap"))
server <- function(input, output) {
output$mymap<- Mapfunc(data=SSdat[[1]], rad= SSdat[[2]], lat = SSdat[[4]], long= SSdat[[3]])
}
shinyApp(ui, server)
# SHINY MAPPING
SSdat <- SubSetMap(data = Shinydf, rad = 20, lat = -72.746286, long = 44.278876, matrix = LLmat)
ui <- fluidPage(
leafletOutput("mymap"))
server <- function(input, output) {
output$mymap<- renderLeaflet({
Mapfunc(data=SSdat[[1]], rad= SSdat[[2]], lat = SSdat[[4]], long= SSdat[[3]])
})
}
shinyApp(ui, server)
runApp('shinyappApiaries/ShinyMapDemo')
runApp('shinyappApiaries/ShinyMapDemo')
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
setwd("~/AlgerProjects/VTApiaries/shinyappApiaries/ShinyMapDemo")
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
runApp()
RegData <- read.csv("RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
# Preliminaries:
# Clear memory of characters:
rm(list=ls())
RegData <- read.csv("RegActiveAndDelinquent.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
FullApiaryDat <- read.csv("VTApiaries.csv",
header=TRUE,
sep = ",",
stringsAsFactors = FALSE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('~/AlgerProjects/VTApiaries/shinyappApiaries/MapDemo')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('~/AlgerProjects/VTApiaries/shinyappApiaries')
runApp('~/AlgerProjects/VTApiaries/shinyappApiaries/MapDemo')
runApp('~/AlgerProjects/VTApiaries/shinyappApiaries/MapDemo1')
runApp('~/AlgerProjects/VTApiaries/shinyappApiaries/MapDemo1')
runApp()
runApp()
runApp()
# Data layers and points on a map, interactive
# Load libraries
library(shiny)
library(leaflet)
# Make data with several positions
data_red=data.frame(LONG=42+rnorm(10), LAT=23+rnorm(10), PLACE=paste("Red_place_",seq(1,10)))
data_blue=data.frame(LONG=42+rnorm(10), LAT=23+rnorm(10), PLACE=paste("Blue_place_",seq(1,10)))
# Initialize the leaflet map:
leaflet() %>%
setView(lng=42, lat=23, zoom=8 ) %>%
# Add two tiles
addProviderTiles("Esri.WorldImagery", group="background 1") %>%
addTiles(options = providerTileOptions(noWrap = TRUE), group="background 2") %>%
# Add 2 marker groups
addCircleMarkers(data=data_red, lng=~LONG , lat=~LAT, radius=8 , color="black",  fillColor="red", stroke = TRUE, fillOpacity = 0.8, group="Red") %>%
addCircleMarkers(data=data_blue, lng=~LONG , lat=~LAT, radius=8 , color="black",  fillColor="blue", stroke = TRUE, fillOpacity = 0.8, group="Blue") %>%
# Add the control widget
addLayersControl(overlayGroups = c("Red","Blue") , baseGroups = c("background 1","background 2"), options = layersControlOptions(collapsed = FALSE))
runApp()
